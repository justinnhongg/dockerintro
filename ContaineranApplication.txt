Docker is a container application that programmers use to put an application on the web. Following Docker Docs instructions, my aim was to containerize an application and be able to access it on a local port system. First, I cloned the getting-started-app repository using a command called git clone, which essentially just copies the files in the public repository into a newly created directory. The folder contained multiple files, most of which probably have to do with the application I am trying to ship and run within a lightweight container. A lightweight container is something that contains an application using the least amount of system resources while still being reliable. The main task was to containerize (put the application into a container) and then access it on a local port system (accessing an application on your own computer on a specific port; think IP address within your computer). Before storing the application within a container, I first needed to create a Dockerfile. A Dockerfile is a text file that contains instructions on how Docker should build and run the container. The first line in a Dockerfile starts with FROM followed by a base image based on the application. In this specific instance, the first line in the Dockerfile was FROM node:lts-alpine. The node refers to Node.js, which allows you to run JavaScript outside the browser. The :lts-alpine just points to a specific version of the Node.js Docker image that has long-term support (LTS) and is running on a specific version of Linux called Alpine (which is great for small containers). The second line contains the location of the working directory, or where the code you want to containerize is. The line in this example was WORKDIR /app. The entire path of the file, i.e., root/getting-started-app/app, is unnecessary because I was running the commands from within the getting-started-app directory, which has direct access to the app directory. The next line copies files or directories into the Dockerfile. The line in this example was COPY . . which essentially copies all the files in the working directory into the Docker image. In other words, all files in the getting-started-app directory are copied into the Docker image. The next line installs dependencies, which are packages (reusable chunks of code) that are necessary to run the program. This example contained the line RUN yarn install --production, which tells Docker to only install dependencies within package.json. The --production part of the argument lets Docker know not to install devDependencies, which are useful for devs while building or maintaining a file, but irrelevant when trying to containerize and run an application. Usually, you would want to install dependencies before copying the actual code because Docker has something called layer caching. Each line is an individual layer that is looked at by Docker separately. If a layer is changed, all layers after would have to be rebuilt. Having dependencies first allows you to change your code without having to redownload dependencies each and every time. The second-to-last line was CMD ["node", "src/index.js"]. This line just tells Docker to run the command node src/index.js, which runs the index.js file using Node. The final line of the Dockerfile was EXPOSE 3000, which just tells Docker to run on port 3000. After writing the Dockerfile in Vim, I ran the command docker build -t getting-started . within the getting-started-app directory to build the image, which contains the instructions needed to create a container (basically what I wrote in the Dockerfile). The . at the end just tells Docker to look for the Dockerfile within the current directory. After creating the image, I needed to start an app container using the docker run -d -p 127.0.0.1:3000:3000 getting-started command. The -d flag directs the container to run in the background while also returning me to the terminal. The -p stands for --publish, which creates a connection between the host and the container. In this specific command, the container's port 3000 is published to 127.0.0.1:3000.
